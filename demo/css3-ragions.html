<!doctype html>
<html>
<head>
<meta charset="gb2312">
<meta http-equiv="Content-Type" content="text/html; charset=gb2312" />
<meta http-equiv="X-UA-Compatible" content="IE=7">
<title>CSS3 Fade slider</title>
<style type="text/css">
*{margin:0;padding:0;}
body{font:14px/1.3 Arial,sans-serif;}
ul,li{list-style:none;}
.header{display:block;width:100%;height:70px;color:#fff;position:relative;background-color:#212121;box-shadow:0 -1px 2px #111;}
.header h2{position:absolute;width:540px;padding:22px 0;font-size:22px;font-weight:normal;left:50%;margin-left:-400px;}
.header a.stuts,
.header a.stuts:visited{position:absolute;top:0;left:50%;margin:23px 0 0 110px;font-size:14px;line-height:31px;color:#fcfcfc;text-decoration:none;}

.container{width:900px;padding:15px;margin:30px auto;background-color:#eee;border-radius:5px;}
​
</style>
<script type="text/javascript">
// 合并排序 
/* 算法核心
/* 将一堆数组中前后相邻的两个有序序列合并成一个有序序列，采用递归来实现，先进行划分，再进行合并。
*/
function merge(left,right){
	var result = [];
	while(left.length>0 && right.length>0){
		if(left[0] < right[0]){
			result.push(left.shift());
		}else{
			result.push(right.shift());
		}
	}
	return result.concat(left,right);
}
function mergeSort(arr){
	if(arr.length<=1){
		return arr;
	}
	var middle = Math.floor(arr.length/2);
	var left = arr.slice(0,middle);
	var right = arr.slice(middle);
	return merge(mergeSort(left),mergeSort(right));
}
// 快速排序 
/* 算法核心
/* 先在数组中选择一个枢纽值，然后将比这个枢纽值小的元素移到左边，大于枢纽值的元素移到后边，对枢纽两边的值递归进行这么操作直至只有一个元素。
*/

function quickSort(arr){
	if(arr.length<=1){
		return arr;
	}
	var pivot = arr.splice(Math.floor(arr.length/2),1)[0];
	var left = [],right=[];
	for(var i=0;i<arr.length;i++){
		if(arr[i]<pivot){
			left.push(arr[i]);
		}else{
			right.push(arr[i]);
		}
	}
	return quickSort(left).concat([pivot],quickSort(right));
}
// 冒泡排序 
/* 算法核心
/* 从上往下扫描数组，比较相邻两个元素，大的在数组的后面，小的在前面，如果不符合则交换二者位置。
*/
function bubbleSort(arr){
	if(arr.length<=1){
		return arr;
	}
	for(var i = arr.length;i>0;i--){
		for(var j=i;j>=0;j--){
			if(arr[j]<arr[j-1]){
				var temp = arr[j];
				arr[j] = arr[j-1];
				arr[j-1] = temp;
			}
		}
	}
	return arr;
}
// 选择排序 
/* 算法核心
/* 首先在未排序序列中找到最小元素，放在排序序列的起始位置，再从未排序序列中找到最小元素放到排序序列末尾位置。
*/
function selectSort(arr){
	var min,temp;
	for(var i = 0 ; i < arr.length ; i++){
		min = i;
		for(var j = i+1 ;j < arr.length ; j++){
			if(arr[min]>arr[j]){
				min = j;
			}
		}
		if(min != i){
			temp = arr[i];
			arr[i] = arr[min];
			arr[min] = temp;
		}
	}
	return arr;
}
// 插入排序 
/* 算法核心
/* 每次从无序列表中取出第一个元素，把它插入到有序表的合适位置，使有序表仍然有序。
*/
function insertSort(arr){
	for(var i=1;i<arr.length;i++){
		var temp = arr[i],j = i;
		while(arr[j-1] > temp){
			arr[j] = arr[j-1];
			--j;
		}
		arr[j] = temp;
	}
	return arr;
}
// 数组的原生Sort方法
// 在sort内传入对比function就可以
var arr = [1,3,5,6,2,4,8,2,23,2];
arr.sort(function(a,b){
	return a - b;
})
console.log(arr);

</script>
</head>
<body>
	<header>
		<div class="header">
			<h2>CSS3 Ragions</h2>
			<a href="#" class="stuts">Back to original tutorial on <span>Script Tutorials</span></a>
		</div>
	</header>
	<div class="container">
		<div id="source">
			<p>To use it, give a name to a thread by using the proposed flow-into CSS property to the region that contains the content. Doing so will remove the content from the normal CSS layout flow. You can then insert this thread into one or more other regions by using the flow-from property.Lorem ipsum dolor </p>
		</div>
		<div id="region1" class="region"></div>
		<div id="region2" class="region"></div>
		<div id="region3" class="region"></div>
	</div>
</body>
</html>